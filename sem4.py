# Сегодня знакомимся с библиотекой numpy - numerical python
# Numpy написана на С, что обеспечивает высокую скорость вычислений
# Numpy лежит в основе многих научных библиотек и пользуется заслуженной популярностью среди исследователей 

#Подключаем библиотеку
import numpy as np
#может так статься, что у вас не найдется эта библиотека - она не стандартная
#тогда ее нужно установить 
#pip install numpy

#основной объект, используемый в numpy - numpy.ndarray - многомерный массив
#чаще всего используются одномерные (векторы) и двумерные (матрицы)

#Самый простой способ сделать numpy array
arr = np.array([1,2,3,4,5])

print(f"Тип arr: {type(arr)}")

#можно узнать различные параметры нашего ndarray

print(f"Форма: {arr.shape}, размерность: {arr.ndim}, размер: {arr.size}, тип хранимых значений: {arr.dtype}")

#Обращение к элементам такое же, как в у обычного списка - через []

print(arr[2])

#Массивы numpy многомерные (np.ndarrays)

matr = np.array([[11,12, 13], [21, 22, 23], [31, 32, 33]])

print(f"Форма: {matr.shape}, размерность: {matr.ndim}, размер: {matr.size}, тип хранимых значений: {matr.dtype}")

#обратите внимание, что есть два способа задать вектор

print(f"вектор: {np.array([1, 2, 3]).shape}, \"одномерная матрица\": {np.array([[1,2,3]]).shape}")

#Рассмотрим некоторые удобные способы создавать ndarray

#можно создать ndarray, заполненный нулями

zero_arr = np.zeros(shape=(7,))
print(f"{zero_arr=}")
#заполненный единицами
ones_matr = np.ones((10, 10), dtype= np.int8) #есть int'ы от 8 до 256 бит (float'ы тоже)
print(f"{ones_matr=}")
#"пустой" - на самом деле заполненный "мусором"
empty_tens = np.empty(shape = (3,3,3)) #трехмерный тензор 3х3х3

#Привет из Си
ones_matr[0][0] += 0.9

lin_arr = np.linspace(0, 10 , 20) #первые два аргумента - диапозон, третий - количество элемнтов. 
#точно знаем размер

agar = np.arange(10, 20, 2) #начало, конец, шаг
#точно знаем шаг


#Матрицы
matr = np.array([[11.,12., 13.], [21., 22., 23.], [31., 32., 33.]])

#чтобы обратиться к элементу матрицы пишем индексы через запятую

#третья строка, первый столбец
print(f"первая строка, третий столбец: {matr[2,0]}")

#вторая строка
print(f"вторая строка: {matr[1, :]}") #или так matr[1]

#третий столбец
print(f"третий столбец: {matr[:, 2]}")

#а теперь вырежем матрицу 2х2 в правом нижнем углу

print(f"матрица 2х2: {matr[1:3,1:3]}")

#можно устанавливать шаг
print(f"матица с шагом 2: {matr[::2,::2]} - отсутствует вторая строка и столбец")

#операции с ndarray

#определены операции сложения, вычитания, умножения, деления, возведения в степень и т.п.
#При этом умножение поэлементное: с = a * b => a[i,j] = a[i,j] * b[i, j]

mult_mat = matr*matr
# можно умножать на константу, столбец или строку с совпадающим размером - broadcasting 
mult_mat /= 2

mult_mat *= np.array([1,2,3])

#также для ndarray определены операции сравнения
matr = np.array([[1, -1, 1], [-1, 1, -1], [1, -1, 1]])

mask = matr > 0 
print(f"{mask=}")

#с помощью получившейся булевой маски можно выбрать элементы

res = matr[mask]
print(f"{res=}")
#обратите внимение - результат является вектором - размерность не совпадает с исходной матрицей!

matr[mask] *= -100
print(f"{matr=}")

#можно применять маску к другим массивам
res = mult_mat[matr<0]
print(f"{res=}")


#основы работы с numpy мы рассмотрели, теперь давайте обсудим полезные методы и функции

#например в прошлом примере мы видели, что при использовании булевой маски у нас не сохранятеся исходная размерность
#это можно исправить, если использовать функцию np.where

res = np.where(mask, mult_mat, 0) #нужно указать, какое значение брать, если условие не выполняется

# функции np.hstack и np.vstack "склеивают" два np.ndarray
# необходимо, что размерность, по которой идет склейка, была одинакова

# сделаем матрицу, добавив первый столбец матрицы res в качестве последней строки

first_col = mult_mat[:,0]
first_col = first_col.reshape(3, -1)
res = np.hstack((mult_mat, first_col)) #заметим, что передаем кортеж из ndarray'ев, которые хотим объединить
#P.S. их может быть не два, а больше

# reshape - функция, которая изменяет форму массива
# аргументы - размерность, к которой приводим
# аршументы -1 отвечают автовыбору
# например, если применим к ndarray с размерностью (16, 1) reshape(4,-1), 
# то получим ndarray с размерностью (4, 4), а если reshape(2, -1), то с размерностью (2, 8)

#теперь "склеим" последний столбец с остальной матрицей

res = np.vstack((res[2], res))


# также есть стат функции среднего квадратичного отклонения и среднего
print(f"Среднее: {res.mean()}, СКО: {res.std(axis=0)}," 
      f"минимум {res.min(axis=1)}")
# есть также отдельные функции np.mean() и np.std()
# в рамках семинара мы рассмотрели лишь функции, которые вам пригодятся для рещения задач
# и при этом не прописанных в указаниях к задачам


#broadcasting
#возможны операции с numpy массивами разных размерностей, если можно их привести

x = np.array([1,2,3,4])
x += 1
print(x)

y = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])
y+= x

print(y)

y += np.array([[-1], [-2], [-3]])
print(y)

x = np.array([[1,2,3]])
y = np.array([[1], [3], [4]])

print(x+y)

x = np.array([1,2,3,4])
y = np.array([1, 2, 3, 4, 5])
#print(x + y)


#Обычный питоновский список
lst = [i for i in range(0, 10**5)]
#Делаем numpy array на основе списка
arr = np.array(lst)

#Измерим время возведения в квадрат всех элементов списка и нампи массива
import timeit

code = """stupid_list = []\nfor i in lst:\n\tstupid_list.append(i**2)"""
stupid_list_time = timeit.timeit(code, number=100,  setup='from __main__ import lst')

list_time = timeit.timeit('[i**2 for i in lst]', number=100,  setup='from __main__ import lst')

array_time = timeit.timeit('arr**2', number=100,  setup='from __main__ import arr')

print(f"Создаем список квадратов с append'ами: {stupid_list_time}")
print(f"Создаем список квадратов при помощи list comprehension: {list_time}")
print(f"Создаем numpy array квадратов: {array_time}")