# План семинара:
# f-строки (продолжение): строки 7 - 42
# Функции (продолжение): строки 43 - 75
# Генераторы
# Модель памяти в Python

# 1. f-строки
# На прошлых занятиях мы рассмотрели f-строки
i:int = 1
c:complex = 1-10j
string:str = "I'm too string today"

fstr: str = "int: {i}, complex {c}, другая строка {string}"
print(fstr)

# Помимо подстановки значений f-строки 
# позволяют манипулировать форматом вывода

#можно указывать ширину
print(f"раз число: {10: 10d}, два число: {10: 5d}")

#попросить вывести знак:

print(f"десять {10}, еще десять {10:+}")

#или вывести с определенной точностью:
e = 2.7182818284
print(f"e: {e:.3f}, тоже e: {e:.5f}")

# еще одна удобная фича
x = 10
print(f"{x=}") # x = значение_х

# экспоненциальная запись
print(f"10**100: {5*10**100:e}, 10**-100: {10**-100:e}, 10: {10:e}")

#Можно по умному, чтобы привычные числа, выводились привычно
print(f"10**100: {5*10**100:g}, 10**-100: {10**-100:g}, 10: {10:g}")

#Можно выводить в разных системах счисления:
print(f"десятичная {12}, двоичная {12:0b}, восьмеричная {12:0o}, шестнадцатеричная {12:0x}")

#Ниже - обычная функция, ничего нового
def simple_f(x:int):
    print(x)
x = 10
simple_f(x)

# Можно устанавливать для параметров функции значения по умолчанию
# Если они есть, то такой аргумент можно не передавать при вызове функции
def default_val_f(y, x: int = 0):
    print(f"{x=}, {y=}")

default_val_f(x, 2*x)
default_val_f(x)
# Порядок передачи аргументов можно менять, если прописывать параметры явно
default_val_f(x = 5, y = 105)

# Можно создать функцию с произвольным числом аргументов
def args_f(x, *args):
    print(x, *args) # добавь в print args и type(args)

args_f(x, 1,2,4,5,6,7,"omg", [1,23,4])

# также можно создать функцию 
# с произвольным количеством именованных аргументов
def args_f(x, **kwargs):
    print(x, kwargs) # добавь в print kwargs и type(kwargs)
args_f(x, kw1=1,another_kw=2,kw3=4,hvatit="omg", eto_spisok=[1,23,4])

# *args и **kwargs часто используются для того,
# чтобы "пробросить" аргументы во внутрянние функции 
# рассмотрим на примере curve_fit
# from scipy.optimize import curve_fit
# curve_fit #1018 строка -- проброс kwargs

# Теперь познакомимся с генератором
def fib():
    prev, cur = 1, 1
    yield prev
    yield cur
    while True:
        prev, cur = cur, prev + cur
        yield cur
        if cur > 100:
            break

fib_gen = fib()
print(next(fib_gen))
print(next(fib_gen))
print(next(fib_gen))
print(next(fib_gen))
print(next(fib_gen))

print("Цикл:\n")
for i in fib_gen:
    print(i)

# Память в питоне работает не так, как в Си
x:int = 5
y:int = x
x = 10
print(f"{x=}, {y=}")
#результат предсказуем

x:list = [1,2,3,4]
y:list = x
y.append(100500)
print(f"{x=}, {y=}")
# а вот тут уже интересно!
# То, что изменение y затронуло x связано с тем, как пайтон работает с памятью
# (на семинаре рассказывал подробно)

a = [1, 2, 3]
b = [1, 2, 3]
c = a

print(f"a == b: {a == b}")  # True - одинаковое содержимое
print(f"a is b: {a is b}")  # False - разные объекты
print(f"a is c: {a is c}")  # True - один и тот же объект

# Разница между изменяемыми и неизменяемыми объектами 
# при передаче их в функцию

def change_immut(x:int) -> int:
    x += 10
    return x

x:int = 10
res = change_immut(x)
print(f"{x=}, {res=}, {id(x)=}, {id(res)=}")

def change_mut(x: list) -> list:
    x.append(5)# а что будет если append(x)
    return x

x:int = [1,2,3,4]
res = change_mut(x)
print(f"{x=}, {res=}, {id(x)=}, {id(res)=}")
# В пайтон числа и небольшие строки хешируются: 
# скорее всего переменные, которые "хранят" 
# небольшие и "захардкоженные" числа/строки 
# будут ссылаться на один объект
  
x=10**10
y=10**10#int(input())*int(input())
print(x == y, x is y)

# Если же все таки хочется скопировать изменяемые объекты?
# .copy
x:dict = {"fist": 1, "second": 2, "third":[1,2,3]}
y:dict = x.copy()
x["forth"] = "new el"
print(x, y, x is y)

# Однако что будет, исли мутабельны вложенные объекты?
x["third"].append(4)
print(x["third"], y["third"], x["third"] is y["third"])
# Как видите, они все еще ссылаются на один объект
# это лечится ф-ией deepcopy из модуля copy

